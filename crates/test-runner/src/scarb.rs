use anyhow::{anyhow, Context, Result};
use camino::Utf8PathBuf;
use itertools::Itertools;
use scarb_metadata::{CompilationUnitMetadata, Metadata, MetadataCommand, PackageId};
use serde::Deserialize;
use std::collections::HashMap;
use std::fs;
use test_collector::LinkedLibrary;

// TODO(#41) TAKEN FROM FORGE, REMOVE AFTER SCARB HAS BEEN MOVED TO A SEPARATE PACKAGE
#[allow(dead_code)]
#[derive(Deserialize, Debug, PartialEq, Clone)]
struct StarknetContract {
    id: String,
    package_name: String,
    contract_name: String,
    artifacts: StarknetContractArtifactPaths,
}

#[allow(dead_code)]
#[derive(Deserialize, Debug, PartialEq, Clone)]
struct StarknetContractArtifactPaths {
    sierra: Utf8PathBuf,
    casm: Utf8PathBuf,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
struct StarknetArtifacts {
    version: u32,
    contracts: Vec<StarknetContract>,
}

/// Contains compiled Starknet artifacts
#[derive(Debug, PartialEq, Clone)]
pub struct StarknetContractArtifacts {
    /// Compiled sierra code
    pub sierra: String,
    /// Compiled casm code
    pub casm: String,
}

/// Represents forge config deserialized from Scarb.toml
#[derive(Deserialize, Debug, PartialEq, Default)]
pub struct ForgeConfig {
    #[serde(default)]
    /// Should runner exit after first failed test
    pub exit_first: bool,
    /// How many runs should fuzzer execute
    pub fuzzer_runs: Option<u32>,
    /// Seed to be used by fuzzer
    pub fuzzer_seed: Option<u64>,

    #[serde(default)]
    pub fork: Vec<ForkTarget>,
}

#[derive(Deserialize, Debug, PartialEq, Default, Clone)]
pub struct ForkTarget {
    pub name: String,
    pub url: String,
    pub block_id: HashMap<String, String>,
}

/// Get deserialized contents of `starknet_artifacts.json` file generated by Scarb
///
/// # Arguments
///
/// * `path` - A path to `starknet_artifacts.json` file.
fn artifacts_for_package(path: &Utf8PathBuf) -> Result<StarknetArtifacts> {
    let starknet_artifacts =
        fs::read_to_string(path).with_context(|| format!("Failed to read {path:?} contents"))?;
    let starknet_artifacts: StarknetArtifacts =
        serde_json::from_str(starknet_artifacts.as_str())
            .with_context(|| format!("Failed to parse {path:?} contents. Make sure you have enabled sierra and casm code generation in Scarb.toml"))?;
    Ok(starknet_artifacts)
}

/// Try getting path to Scarb starknet artifacts for the given package
///
/// Try getting the path to `starknet_artifacts.json` file that is generated by `scarb build` command.
/// If the file is not present, for example when package doesn't define the starknet target, `None` is returned.
///
/// # Arguments
///
/// * `path` - A path to the Scarb package
/// * `target_name` - A name of the target that is being built by Scarb
pub fn try_get_starknet_artifacts_path(
    target_dir: &Utf8PathBuf,
    target_name: &str,
) -> Result<Option<Utf8PathBuf>> {
    let path = target_dir.join("dev");
    let paths = fs::read_dir(path);
    let Ok(mut paths) = paths else {
        return Ok(None);
    };
    let starknet_artifacts = paths.find_map(|path| match path {
        Ok(path) => {
            let name = path.file_name().into_string().ok()?;
            (name == format!("{target_name}.starknet_artifacts.json")).then_some(path.path())
        }
        Err(_) => None,
    });
    let starknet_artifacts: Option<Result<Utf8PathBuf>> = starknet_artifacts.map(|artifacts| {
        Utf8PathBuf::try_from(artifacts.clone())
            .with_context(|| format!("Failed to convert path = {artifacts:?} to Utf8PathBuf"))
    });
    starknet_artifacts.transpose()
}

/// Get the map with `StarknetContractArtifacts` for the given package
///
/// # Arguments
///
/// * path - A path to the Scarb package
pub fn get_contracts_map(path: &Utf8PathBuf) -> Result<HashMap<String, StarknetContractArtifacts>> {
    let base_path = path
        .parent()
        .ok_or_else(|| anyhow!("Failed to get parent for path = {}", path))?;
    let artifacts = artifacts_for_package(path)?;
    let mut map = HashMap::new();
    for contract in artifacts.contracts {
        let name = contract.contract_name;
        let sierra_path = base_path.join(contract.artifacts.sierra);
        let casm_path = base_path.join(contract.artifacts.casm);
        let sierra = fs::read_to_string(sierra_path)?;
        let casm = fs::read_to_string(casm_path)?;
        map.insert(name, StarknetContractArtifacts { sierra, casm });
    }
    Ok(map)
}

/// Get Forge config from the `Scarb.toml` file
///
/// # Arguments
///
/// * `metadata` - Scarb metadata object
/// * `package` - Id of the Scarb package
pub fn config_from_scarb_for_package(
    metadata: &Metadata,
    package: &PackageId,
) -> Result<ForgeConfig> {
    let raw_metadata = metadata
        .get_package(package)
        .ok_or_else(|| anyhow!("Failed to find metadata for package = {package}"))?
        .tool_metadata("snforge");
    let config = raw_metadata.map_or_else(
        || Ok(Default::default()),
        |raw_metadata| Ok(serde_json::from_value(raw_metadata.clone())?),
    );
    validate_fork_config(config)
}

fn compilation_unit_for_package<'a>(
    metadata: &'a Metadata,
    package: &PackageId,
) -> Result<&'a CompilationUnitMetadata> {
    metadata
        .compilation_units
        .iter()
        .filter(|unit| unit.package == *package)
        .min_by_key(|unit| match unit.target.name.as_str() {
            name @ "starknet-contract" => (0, name),
            name @ "lib" => (1, name),
            name => (2, name),
        })
        .ok_or_else(|| anyhow!("Failed to find metadata for package = {package}"))
}

/// Get the target name for the given package
pub fn target_name_for_package(metadata: &Metadata, package: &PackageId) -> Result<String> {
    let compilation_unit = compilation_unit_for_package(metadata, package)?;
    Ok(compilation_unit.target.name.clone())
}

/// Get the path to Cairo corelib for the given package
pub fn corelib_for_package(metadata: &Metadata, package: &PackageId) -> Result<Utf8PathBuf> {
    let compilation_unit = compilation_unit_for_package(metadata, package)?;
    let corelib = compilation_unit
        .components
        .iter()
        .find(|du| du.name == "core")
        .context("corelib could not be found")?;
    Ok(Utf8PathBuf::from(corelib.source_root()))
}

/// Get the top-level and main file paths for the given package
pub fn paths_for_package(
    metadata: &Metadata,
    package: &PackageId,
) -> Result<(Utf8PathBuf, Utf8PathBuf)> {
    let compilation_unit = compilation_unit_for_package(metadata, package)?;

    let package = metadata
        .get_package(package)
        .ok_or_else(|| anyhow!("Failed to find metadata for package = {package}"))?;

    let package_path = package.root.clone();
    let package_source_dir_path = compilation_unit.target.source_root();

    Ok((package_path, Utf8PathBuf::from(package_source_dir_path)))
}

pub fn target_dir_for_package(workspace_root: &Utf8PathBuf) -> Result<Utf8PathBuf> {
    let scarb_metadata = MetadataCommand::new().inherit_stderr().exec()?;

    let target_dir = scarb_metadata
        .target_dir
        .unwrap_or_else(|| workspace_root.join("target"));

    Ok(target_dir)
}

/// Get a name of the given package
pub fn name_for_package(metadata: &Metadata, package: &PackageId) -> Result<String> {
    let package = metadata
        .get_package(package)
        .ok_or_else(|| anyhow!("Failed to find metadata for package = {package}"))?;

    Ok(package.name.clone())
}

/// Get the dependencies for the given package
pub fn dependencies_for_package(
    metadata: &Metadata,
    package: &PackageId,
) -> Result<Vec<LinkedLibrary>> {
    let compilation_unit = compilation_unit_for_package(metadata, package)?;
    let dependencies = compilation_unit
        .components
        .iter()
        .filter(|du| &du.name != "core")
        .map(|cu| LinkedLibrary {
            name: cu.name.clone(),
            path: cu.source_root().to_owned().into_std_path_buf(),
        })
        .collect();

    Ok(dependencies)
}

fn validate_fork_config(config: Result<ForgeConfig>) -> Result<ForgeConfig> {
    if let Ok(ForgeConfig { fork: forks, .. }) = &config {
        let names: Vec<String> = forks.iter().map(|fork| fork.name.clone()).collect();
        let removed_duplicated_names: Vec<String> = names.clone().into_iter().unique().collect();

        if names.len() != removed_duplicated_names.len() {
            return Err(anyhow!("Some fork names are duplicated"));
        }

        for fork in forks {
            let block_id_items: Vec<(&String, &String)> = fork.block_id.iter().collect();
            let [(block_id_key, block_id_value)] = block_id_items[..] else {
                return Err(anyhow!("block_id should be set once per fork"));
            };

            if !["number", "hash", "tag"].contains(&&**block_id_key) {
                return Err(anyhow!(
                    "block_id has only three variants: number, hash and tag"
                ));
            }

            if block_id_key == "tag" && !["Latest", "Pending"].contains(&&**block_id_value) {
                return Err(anyhow!(
                    "block_id.tag has only two variants: Latest or Pending"
                ));
            }
        }
    }

    config
}
